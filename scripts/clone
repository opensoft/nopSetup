#!/bin/bash

# Enable verbose mode if --verbose or -v is passed
VERBOSE=false
if [[ "$1" == "--verbose" || "$1" == "-v" ]]; then
  VERBOSE=true
  shift
fi

# Function to echo messages in verbose mode
log() {
  if [ "$VERBOSE" = true ]; then
    echo "[DEBUG] $1"
  fi
}

# Function to find root by traversing up and looking for a specific directory name (case-insensitive)
find_root_by_dir_name() {
  local target_name_lower=$(echo "$1" | tr '[:upper:]' '[:lower:]')
  local dir="$2"
  log "find_root_by_dir_name: Starting search for directory '$1' (case-insensitive) from '$dir'"

  # Check the starting directory itself first
  local current_basename=$(basename "$dir")
  local current_basename_lower=$(echo "$current_basename" | tr '[:upper:]' '[:lower:]')
  if [ "$current_basename_lower" = "$target_name_lower" ]; then
    log "find_root_by_dir_name: Found target directory at starting path '$dir'"
    echo "$dir"
    return 0
  fi

  # Traverse up
  while [ "$dir" != "/" ]; do
    local parent_dir=$(dirname "$dir")
    log "find_root_by_dir_name: Checking parent '$parent_dir'"

    # Check if parent directory is readable
    if [ ! -r "$parent_dir" ]; then
        log "find_root_by_dir_name: Error - Cannot read parent directory '$parent_dir'. Permission denied?"
        return 1 # Cannot traverse further up
    fi

    local parent_basename=$(basename "$parent_dir")
    local parent_basename_lower=$(echo "$parent_basename" | tr '[:upper:]' '[:lower:]')
    if [ "$parent_basename_lower" = "$target_name_lower" ]; then
      log "find_root_by_dir_name: Found target directory at '$parent_dir'"
      echo "$parent_dir"
      return 0
    fi

    # Break if we reached the actual root without finding it
    if [ "$parent_dir" = "/" ]; then
        log "find_root_by_dir_name: Reached filesystem root '/', target directory not found."
        break
    fi

    dir="$parent_dir"
    # Safety break if dir becomes empty
    if [ -z "$dir" ]; then
        log "find_root_by_dir_name: Error - Directory became empty during traversal."
        return 1
    fi
  done

  log "find_root_by_dir_name: Reached end of traversal, target directory not found."
  return 1
}

# --- START MODIFICATION: Find root based on environment variable OR directory name ---
log "Determining project root..."
NOPCOMMERCE_ROOT=""
CURRENT_PWD=$(pwd)

# 1. Check Environment Variable (Primary Method)
FRAMEWORK_ENV_VAR="${DEV_CONTAINER_FRAMEWORK:-}" # Read env var, default to empty if unset
LOWERCASE_FRAMEWORK_ENV_VAR=$(echo "$FRAMEWORK_ENV_VAR" | tr '[:upper:]' '[:lower:]')
log "DEV_CONTAINER_FRAMEWORK: '$FRAMEWORK_ENV_VAR' (Lowercase: '$LOWERCASE_FRAMEWORK_ENV_VAR')"

if [[ "$LOWERCASE_FRAMEWORK_ENV_VAR" == "nopcommerce" ]]; then
    # Assume the standard workspace root for this framework
    NOPCOMMERCE_ROOT="/workspace"
    log "Method 1 (Env Var): Found DEV_CONTAINER_FRAMEWORK='nopcommerce'. Setting root to $NOPCOMMERCE_ROOT."
else
    log "Method 1 (Env Var): DEV_CONTAINER_FRAMEWORK not set to 'nopcommerce'. Trying Method 2."

    # 2. Find by Directory Name (Fallback Method)
    log "Method 2 (Dir Name): Searching for 'nopCommerce' directory (case-insensitive) upwards from '$CURRENT_PWD'..."
    POTENTIAL_ROOT=$(find_root_by_dir_name "nopCommerce" "$CURRENT_PWD")
    FIND_ROOT_EXIT_CODE=$?

    if [ $FIND_ROOT_EXIT_CODE -eq 0 ] && [ -n "$POTENTIAL_ROOT" ]; then
        NOPCOMMERCE_ROOT="$POTENTIAL_ROOT"
        log "Method 2 (Dir Name): Found nopCommerce directory at '$NOPCOMMERCE_ROOT'. Setting root."
    else
        log "Method 2 (Dir Name): Could not find 'nopCommerce' directory by traversing up."
    fi
fi

# Final Check
if [ -z "$NOPCOMMERCE_ROOT" ]; then
    echo "Error: Could not determine the nopCommerce project root."
    echo "Please ensure either:"
    echo "  1. The DEV_CONTAINER_FRAMEWORK environment variable is set to 'NOPCOMMERCE' (case-insensitive) within the container (currently '$FRAMEWORK_ENV_VAR')."
    echo "  2. You are running this script from within a directory structure where a parent directory is named 'nopCommerce' (case-insensitive)."
    exit 1
fi

log "Successfully determined project root: $NOPCOMMERCE_ROOT"
# --- END MODIFICATION ---

# Save the current working directory
CURRENT_DIR=$(pwd)
log "Current directory: $CURRENT_DIR"

# Change to the nopCommerce root directory
log "Changing to nopCommerce root directory: $NOPCOMMERCE_ROOT"
cd "$NOPCOMMERCE_ROOT" || exit 1 # Exit if cd fails

# --- START RE-INSERTED SOLUTION FINDING LOGIC ---
SUB_PROJECT_DIR=""      # Directory name if SLN is in subdir (e.g., "Nop.Web")
SUB_PROJECT_PATH=""     # Absolute path to subdir if SLN is in subdir (e.g., "/workspace/Nop.Web")
SOLUTION_FILE=""        # Absolute path to the .sln file
SOLUTION_DIR=""         # Absolute path to the directory containing the .sln file

# Attempt 1: Check for SLN at root matching DEV_CONTAINER_PROJECT (case-insensitive)
PROJECT_ENV_VAR="${DEV_CONTAINER_PROJECT:-}" # Read env var, default to empty
log "Attempt 1: Checking for SLN based on DEV_CONTAINER_PROJECT ('$PROJECT_ENV_VAR')..."
if [ -n "$PROJECT_ENV_VAR" ]; then
    PROJECT_ENV_VAR_LOWER=$(echo "$PROJECT_ENV_VAR" | tr '[:upper:]' '[:lower:]')
    log "Checking for SLN at root matching '$PROJECT_ENV_VAR' (case-insensitive)..."
    # Iterate through all .sln files at the root
    for file_path in "$NOPCOMMERCE_ROOT"/*.sln; do
        # Check if the glob found any files and if the current item is a file
        if [ -e "$file_path" ] && [ -f "$file_path" ]; then
            filename=$(basename "$file_path")
            filename_no_ext="${filename%.*}" # Remove .sln extension
            filename_no_ext_lower=$(echo "$filename_no_ext" | tr '[:upper:]' '[:lower:]')
            log "Comparing '$filename_no_ext_lower' (from file) with '$PROJECT_ENV_VAR_LOWER' (from env var)"
            # Compare lowercase versions
            if [ "$filename_no_ext_lower" = "$PROJECT_ENV_VAR_LOWER" ]; then
                SOLUTION_FILE="$file_path"
                SOLUTION_DIR="$NOPCOMMERCE_ROOT"
                log "Found solution file at root via env var (case-insensitive): $SOLUTION_FILE"
                break # Exit loop once found
            fi
        fi
    done
    # Log if not found after checking all files
    if [ -z "$SOLUTION_FILE" ]; then
        log "Solution file not found at root based on DEV_CONTAINER_PROJECT (case-insensitive)."
    fi
else
    log "DEV_CONTAINER_PROJECT environment variable not set."
fi

# Attempt 2 (Fallback): Find SLN in subdir matching subdir name (case-insensitive)
if [ -z "$SOLUTION_FILE" ]; then
    log "Attempt 2 (Fallback): Searching for SLN in a subdirectory (e.g., SubDir/SubDir.sln)..."
    # Find directories directly under NOPCOMMERCE_ROOT
    for dir_path in "$NOPCOMMERCE_ROOT"/*/; do
        # Check if it's actually a directory
        if [ -d "$dir_path" ]; then
            dir_name=$(basename "$dir_path")
            dir_name_lower=$(echo "$dir_name" | tr '[:upper:]' '[:lower:]') # Lowercase dir name
            # Construct potential solution file path
            potential_sln_file_subdir="${dir_path}${dir_name}.sln"
            log "Checking for potential solution file in subdir: $potential_sln_file_subdir"
            # Check if the potential solution file exists (case-sensitive check on filename is ok here)
            if [ -f "$potential_sln_file_subdir" ]; then
                 # Now check if the directory name matches the SLN filename base (case-insensitive)
                 sln_basename=$(basename "$potential_sln_file_subdir")
                 sln_basename_no_ext="${sln_basename%.*}"
                 sln_basename_no_ext_lower=$(echo "$sln_basename_no_ext" | tr '[:upper:]' '[:lower:]')
                 log "Comparing subdir name '$dir_name_lower' with SLN base name '$sln_basename_no_ext_lower'"
                 if [ "$dir_name_lower" = "$sln_basename_no_ext_lower" ]; then
                    SUB_PROJECT_DIR="$dir_name"
                    SUB_PROJECT_PATH="$NOPCOMMERCE_ROOT/$SUB_PROJECT_DIR"
                    SOLUTION_FILE="$potential_sln_file_subdir"
                    SOLUTION_DIR="$SUB_PROJECT_PATH" # SLN is inside the sub-project path
                    log "Found sub-project directory: $SUB_PROJECT_DIR"
                    log "Found solution file in subdir (case-insensitive match): $SOLUTION_FILE"
                    log "Sub-project path: $SUB_PROJECT_PATH"
                    break # Exit the loop once found
                 else
                    log "Subdir name does not match SLN base name (case-insensitive)."
                 fi
            fi
        fi
    done
fi
# --- END RE-INSERTED SOLUTION FINDING LOGIC ---

# Final Check
if [ -z "$SOLUTION_FILE" ]; then
    echo "Error: Could not find the solution file."
    echo "Checked for:"
    echo "  1. '$NOPCOMMERCE_ROOT/\$DEV_CONTAINER_PROJECT.sln' (DEV_CONTAINER_PROJECT='$PROJECT_ENV_VAR', case-insensitive)"
    echo "  2. A subdirectory pattern like '$NOPCOMMERCE_ROOT/SubDir/SubDir.sln' (where SubDir name matches SLN name, case-insensitive)"
    cd "$CURRENT_DIR" # Go back to original dir before exiting
    exit 1
fi
log "Using Solution File: $SOLUTION_FILE"
log "Using Solution Directory: $SOLUTION_DIR"
# --- END MODIFICATION ---

# Define DEVOPS_PROJECT early so it's available in all blocks (Original position before restructuring)
DEVOPS_PROJECT="FarHeapSolutions@vs-ssh.visualstudio.com:v3/FarHeapSolutions/Nop%20Plugins"

# Check if a repository name argument is provided (Original position)
if [ -z "$1" ]; then
  echo "Usage: clone [--verbose | -v] [--remove | -rm] [--site | -s] <repo-name>"
  cd "$CURRENT_DIR"
  exit 1
fi

# Suggest correct usage if the user types `-r` instead of `-rm` (Original position)
if [[ "$1" == "-r" ]]; then
  echo "Error: Invalid option '-r'. Did you mean 'clone -rm <repo-name>'?"
  cd "$CURRENT_DIR"
  exit 1
fi

# Check for verbose and remove options without arguments (Original position)
if [[ "$1" == "--verbose" || "$1" == "-v" ]] && [ -z "$2" ]; then
  echo "Error: The --verbose or -v option must be followed by a repository name or action."
  echo "Usage: clone [--verbose | -v] [--remove | -rm] [--site | -s] <repo-name>"
  cd "$CURRENT_DIR"
  exit 1
fi

if [[ "$1" == "--remove" || "$1" == "-rm" ]] && [ -z "$2" ]]; then
  echo "Usage: clone [--verbose | -v] [--remove | -rm] [--site | -s] <repo-name>"
  cd "$CURRENT_DIR"
  exit 1
fi

# Check for the --site or -s option (Original position, duplicated logic will be restored later)
if [[ "$1" == "--site" || "$1" == "-s" ]]; then
  # ... Original site cloning logic (will be restored at the end) ...
  # This block was originally much larger and duplicated
  # For now, just acknowledge it was here. We restore the full duplication later.
  log "Site cloning logic was originally here (part 1)."
fi

# Check for the --site or -s option with --remove or -rm (Original position, duplicated logic will be restored later)
if [[ "$1" == "--remove" || "$1" == "-rm" ]] && [[ "$2" == "--site" || "$2" == "-s" ]]; then
  # ... Original site removal logic (will be restored at the end) ...
  # This block was originally much larger and duplicated
  # For now, just acknowledge it was here. We restore the full duplication later.
  log "Site removal logic was originally here (part 1)."
fi


# Variables (Original definition position)
ACTION=$1
REPO_NAME=$2
if [[ "$ACTION" != "--remove" && "$ACTION" != "-rm" ]]; then
  REPO_NAME=$1
fi
REPO_SLUG="Nop.Plugin.Opensoft.$REPO_NAME"

# --- START PATH ADJUSTMENTS ---
PLUGIN_ROOT_RELATIVE_TO_WORKSPACE="src/Plugins" # Standard location relative to /workspace
CLONE_DIR_ABSOLUTE="$NOPCOMMERCE_ROOT/$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$REPO_SLUG" # Absolute path for cloning/removal

# Path of the plugin project relative to the SOLUTION_DIR
if [ -n "$SUB_PROJECT_DIR" ]; then
    # SLN is in a subdir, project path needs to be relative to that subdir
    PROJECT_PATH_FOR_SLN="../$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$REPO_SLUG/$REPO_SLUG.csproj"
    # Path for .gitignore relative to NOPCOMMERCE_ROOT
    GITIGNORE_RELATIVE_DIR="$SUB_PROJECT_DIR/$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$REPO_SLUG"
else
    # SLN is at the root, project path is relative to the root
    PROJECT_PATH_FOR_SLN="$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$REPO_SLUG/$REPO_SLUG.csproj"
    # Path for .gitignore relative to NOPCOMMERCE_ROOT
    GITIGNORE_RELATIVE_DIR="$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$REPO_SLUG"
fi
# --- END PATH ADJUSTMENTS ---

GITIGNORE_PATH="$NOPCOMMERCE_ROOT/.gitignore" # Absolute path to gitignore

log "Action: $ACTION"
log "Repository name: $REPO_NAME"
log "Repository slug: $REPO_SLUG"
log "Clone directory (Absolute): $CLONE_DIR_ABSOLUTE"
log "Project Path for SLN (Relative): $PROJECT_PATH_FOR_SLN"
log "Gitignore Path (Absolute): $GITIGNORE_PATH"
log "Gitignore Relative Dir: $GITIGNORE_RELATIVE_DIR"
log "Solution file: $SOLUTION_FILE"
log "Solution directory: $SOLUTION_DIR"

# Handle removal (Original logic)
if [[ "$ACTION" == "--remove" || "$ACTION" == "-rm" ]]; then
  echo "Removing repository '$REPO_SLUG'..."

  # Remove the folder
  if [ -d "$CLONE_DIR_ABSOLUTE" ]; then
    log "Removing folder: $CLONE_DIR_ABSOLUTE"
    rm -rf "$CLONE_DIR_ABSOLUTE"
    # Check if rm was successful
    if [ $? -eq 0 ]; then
      echo "Folder '$CLONE_DIR_ABSOLUTE' removed successfully."
    else
      echo "Error: Failed to remove folder '$CLONE_DIR_ABSOLUTE'. Skipping further actions for this repository."
      cd "$CURRENT_DIR"
      exit 1
    fi
  else
    echo "Folder '$CLONE_DIR_ABSOLUTE' does not exist."
  fi

  # Remove the .gitignore entry
  if [ -f "$GITIGNORE_PATH" ]; then
    log "Removing .gitignore entry for '$GITIGNORE_RELATIVE_DIR/'..."
    sed -i "\|^$GITIGNORE_RELATIVE_DIR/$|d" "$GITIGNORE_PATH"
    echo ".gitignore entry for '$GITIGNORE_RELATIVE_DIR/' removed."
    log "Committing changes to .gitignore..."
    cd "$(dirname "$GITIGNORE_PATH")" || exit 1
    git add .gitignore
    git commit -m "Removed .gitignore entry for '$GITIGNORE_RELATIVE_DIR/'"
    echo "Changes committed to .gitignore."
    cd "$NOPCOMMERCE_ROOT" || exit 1
  else
    echo "Error: .gitignore file not found at '$GITIGNORE_PATH'."
  fi

  # Remove the project from the solution file
  if [ -f "$SOLUTION_FILE" ]; then
    log "Changing directory to solution directory: $SOLUTION_DIR"
    cd "$SOLUTION_DIR" || exit 1
    
    log "Removing project '$PROJECT_PATH_FOR_SLN' from solution file..."
    dotnet sln "$SOLUTION_FILE" remove "$PROJECT_PATH_FOR_SLN"
    if [ $? -eq 0 ]; then
      echo "Project '$REPO_SLUG' removed from the solution successfully."
    else
      echo "Warning: Failed to remove project '$PROJECT_PATH_FOR_SLN' from the solution (maybe it wasn't there?)."
    fi
    cd "$NOPCOMMERCE_ROOT" || exit 1
  else
    echo "Error: Solution file '$SOLUTION_FILE' not found."
  fi

  # Exit after removal
  cd "$CURRENT_DIR"
  echo "Repository '$REPO_SLUG' removed successfully."
  exit 0
fi

# Clone the repository into ./src/Plugins/ (Original logic, without extra debug lines)
echo "Cloning repository '$REPO_SLUG'..."
log "Cloning using '$DEVOPS_PROJECT/$REPO_SLUG'..."
log "Cloning into '$CLONE_DIR_ABSOLUTE'..."
git clone "$DEVOPS_PROJECT/$REPO_SLUG" "$CLONE_DIR_ABSOLUTE"

if [ $? -ne 0 ]; then
  echo "Error: Failed to clone repository '$REPO_SLUG'."
  cd "$CURRENT_DIR"
  exit 1
fi

echo "Repository '$REPO_SLUG' cloned successfully into '$CLONE_DIR_ABSOLUTE'."

# Change to the 4.80/develop branch
cd "$CLONE_DIR_ABSOLUTE" || exit 1
log "Switching to branch '4.80/develop'..."
git checkout 4.80/develop

if [ $? -ne 0 ]; then
  echo "Error: Failed to switch to branch '4.80/develop'."
  cd "$CURRENT_DIR"
  exit 1
fi

log "Switched to branch '4.80/develop' successfully."

# Update the .gitignore file
if [ -f "$GITIGNORE_PATH" ]; then
  echo "Updating .gitignore located at '$GITIGNORE_PATH'..."
  log "Checking if '$GITIGNORE_RELATIVE_DIR/' is already in .gitignore..."
  
  if ! grep -qF "$GITIGNORE_RELATIVE_DIR/" "$GITIGNORE_PATH"; then
    log "Adding '$GITIGNORE_RELATIVE_DIR/' to .gitignore..."
    if [[ -s "$GITIGNORE_PATH" && $(tail -c1 "$GITIGNORE_PATH" | wc -l) -eq 0 ]]; then
      echo "" >> "$GITIGNORE_PATH"
    fi
    echo "$GITIGNORE_RELATIVE_DIR/" >> "$GITIGNORE_PATH"
    echo ".gitignore updated with '$GITIGNORE_RELATIVE_DIR/'."
    
    log "Committing changes to .gitignore..."
    cd "$(dirname "$GITIGNORE_PATH")" || exit 1
    git add .gitignore
    git commit -m "Updated .gitignore to ignore '$GITIGNORE_RELATIVE_DIR/'"
    echo "Changes committed to .gitignore."
    cd "$NOPCOMMERCE_ROOT" || exit 1
  else
    echo "'$GITIGNORE_RELATIVE_DIR/' is already present in .gitignore."
    cd "$NOPCOMMERCE_ROOT" || exit 1
  fi
else
  echo "Error: .gitignore file not found at '$GITIGNORE_PATH'."
  cd "$CURRENT_DIR"
  exit 1
fi

# Add the cloned project to the solution file
if [ -f "$SOLUTION_FILE" ]; then
  log "Changing directory to solution directory: $SOLUTION_DIR"
  cd "$SOLUTION_DIR" || exit 1
  
  echo "Adding '$PROJECT_PATH_FOR_SLN' to the solution file '$SOLUTION_FILE'..."
  log "Running 'dotnet sln add' for '$PROJECT_PATH_FOR_SLN'..."
  if [ -f "$PROJECT_PATH_FOR_SLN" ]; then
      dotnet sln "$SOLUTION_FILE" add "$PROJECT_PATH_FOR_SLN"
      if [ $? -eq 0 ]; then
        echo "Project '$REPO_SLUG' added to the solution successfully."
      else
        echo "Error: Failed to add project '$PROJECT_PATH_FOR_SLN' to the solution."
      fi
  else
      echo "Error: Project file '$PROJECT_PATH_FOR_SLN' not found. Cannot add to solution."
  fi
  cd "$NOPCOMMERCE_ROOT" || exit 1
else
  echo "Error: Solution file '$SOLUTION_FILE' not found."
fi

# Return to the original working directory
log "Returning to the original working directory: $CURRENT_DIR"
cd "$CURRENT_DIR"

echo "Script completed successfully."


# --- Restore the duplicated site cloning logic ---
# Check for the --site or -s option (Cloning) - Duplicated block from original script
if [[ "$1" == "--site" || "$1" == "-s" ]]; then
  # Ensure a site name is provided
  if [ -z "$2" ]; then
    echo "Error: The --site or -s option must be followed by a site name."
    echo "Usage: clone --site <site-name>"
    exit 1
  fi

  SITE_NAME=$2
  # Construct path relative to NOPCOMMERCE_ROOT (adjust if SUB_PROJECT_PATH was used before)
  PLUGIN_LIST_FILE="$NOPCOMMERCE_ROOT/.devcontainer/sites/$SITE_NAME/PluginList.txt" # Assuming root contains .devcontainer

  # Ensure the PluginList.txt file exists
  if [ ! -f "$PLUGIN_LIST_FILE" ]; then
    echo "Error: PluginList.txt file not found at '$PLUGIN_LIST_FILE'."
    exit 1
  fi

  echo "Cloning repositories for site '$SITE_NAME' listed in $PLUGIN_LIST_FILE..."

  # Read each line in the PluginList.txt file
  while IFS= read -r REPO_NAME_FROM_FILE || [ -n "$REPO_NAME_FROM_FILE" ]; do
    # Skip empty lines or lines starting with #
    if [[ -z "$REPO_NAME_FROM_FILE" || "$REPO_NAME_FROM_FILE" == \#* ]]; then
      continue
    fi

    # Reconstruct variables for this specific repo name within the loop
    CURRENT_REPO_SLUG="Nop.Plugin.Opensoft.$REPO_NAME_FROM_FILE"
    CURRENT_CLONE_DIR_ABSOLUTE="$NOPCOMMERCE_ROOT/$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG"

    # Determine paths relative to solution for this repo
    if [ -n "$SUB_PROJECT_DIR" ]; then
        CURRENT_PROJECT_PATH_FOR_SLN="../$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG/$CURRENT_REPO_SLUG.csproj"
        CURRENT_GITIGNORE_RELATIVE_DIR="$SUB_PROJECT_DIR/$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG"
    else
        CURRENT_PROJECT_PATH_FOR_SLN="$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG/$CURRENT_REPO_SLUG.csproj"
        CURRENT_GITIGNORE_RELATIVE_DIR="$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG"
    fi

    echo "--- Processing $REPO_NAME_FROM_FILE ---"

    # Clone
    echo "Cloning repository '$CURRENT_REPO_SLUG'..."
    log "Cloning into '$CURRENT_CLONE_DIR_ABSOLUTE'..."
    git clone "$DEVOPS_PROJECT/$CURRENT_REPO_SLUG" "$CURRENT_CLONE_DIR_ABSOLUTE"
    if [ $? -ne 0 ]; then echo "Error cloning $CURRENT_REPO_SLUG. Skipping."; continue; fi
    echo "Repository '$CURRENT_REPO_SLUG' cloned."

    # Checkout branch
    cd "$CURRENT_CLONE_DIR_ABSOLUTE" || { echo "Error cd'ing to $CURRENT_CLONE_DIR_ABSOLUTE. Skipping."; cd "$NOPCOMMERCE_ROOT"; continue; }
    log "Switching to branch '4.80/develop'..."
    git checkout 4.80/develop
    if [ $? -ne 0 ]; then echo "Error checking out branch for $CURRENT_REPO_SLUG. Skipping."; cd "$NOPCOMMERCE_ROOT"; continue; fi
    log "Switched branch."
    cd "$NOPCOMMERCE_ROOT" || exit 1 # Go back to root

    # Update gitignore
    if [ -f "$GITIGNORE_PATH" ]; then
      if ! grep -qF "$CURRENT_GITIGNORE_RELATIVE_DIR/" "$GITIGNORE_PATH"; then
        log "Adding '$CURRENT_GITIGNORE_RELATIVE_DIR/' to .gitignore..."
        if [[ -s "$GITIGNORE_PATH" && $(tail -c1 "$GITIGNORE_PATH" | wc -l) -eq 0 ]]; then echo "" >> "$GITIGNORE_PATH"; fi
        echo "$CURRENT_GITIGNORE_RELATIVE_DIR/" >> "$GITIGNORE_PATH"
        log "Committing .gitignore changes..."
        cd "$(dirname "$GITIGNORE_PATH")" || exit 1
        git add .gitignore
        git commit -m "Updated .gitignore for '$CURRENT_GITIGNORE_RELATIVE_DIR/'"
        cd "$NOPCOMMERCE_ROOT" || exit 1
      else
        log "'$CURRENT_GITIGNORE_RELATIVE_DIR/' already in .gitignore."
        # Go back to root even if no change was made (original script might have missed this)
        cd "$NOPCOMMERCE_ROOT" || exit 1
      fi
    else echo "Error: .gitignore not found at '$GITIGNORE_PATH'."; fi

    # Add to solution
    if [ -f "$SOLUTION_FILE" ]; then
      log "Changing directory to solution directory: $SOLUTION_DIR"
      cd "$SOLUTION_DIR" || exit 1
      log "Adding '$CURRENT_PROJECT_PATH_FOR_SLN' to solution..."
      if [ -f "$CURRENT_PROJECT_PATH_FOR_SLN" ]; then
          dotnet sln "$SOLUTION_FILE" add "$CURRENT_PROJECT_PATH_FOR_SLN"
          if [ $? -ne 0 ]; then echo "Error adding '$CURRENT_PROJECT_PATH_FOR_SLN' to solution."; fi
      else echo "Error: Project file '$CURRENT_PROJECT_PATH_FOR_SLN' not found."; fi
      cd "$NOPCOMMERCE_ROOT" || exit 1
    else echo "Error: Solution file '$SOLUTION_FILE' not found."; fi

    echo "--- Finished $REPO_NAME_FROM_FILE ---"

  done < "$PLUGIN_LIST_FILE"

  echo "All repositories for site '$SITE_NAME' listed in $PLUGIN_LIST_FILE processed."
  exit 0
fi

# --- Restore the duplicated site removal logic ---
# Check for the --site or -s option with --remove or -rm - Duplicated block from original script
if [[ "$1" == "--remove" || "$1" == "-rm" ]] && [[ "$2" == "--site" || "$2" == "-s" ]]; then
  # Ensure a site name is provided
  if [ -z "$3" ]; then
    echo "Error: The --site or -s option must be followed by a site name."
    echo "Usage: clone -rm --site <site-name>"
    exit 1
  fi

  SITE_NAME=$3
  # Construct path relative to NOPCOMMERCE_ROOT (adjust if SUB_PROJECT_PATH was used before)
  PLUGIN_LIST_FILE="$NOPCOMMERCE_ROOT/.devcontainer/sites/$SITE_NAME/PluginList.txt" # Assuming root contains .devcontainer

  # Ensure the PluginList.txt file exists
  if [ ! -f "$PLUGIN_LIST_FILE" ]; then
    echo "Error: PluginList.txt file not found at '$PLUGIN_LIST_FILE'."
    exit 1
  fi

  echo "Removing repositories for site '$SITE_NAME' listed in $PLUGIN_LIST_FILE..."

  # Read each line in the PluginList.txt file
  while IFS= read -r REPO_NAME_FROM_FILE || [ -n "$REPO_NAME_FROM_FILE" ]; do
    # Skip empty lines or lines starting with #
    if [[ -z "$REPO_NAME_FROM_FILE" || "$REPO_NAME_FROM_FILE" == \#* ]]; then
      continue
    fi

    # Reconstruct variables for this specific repo name within the loop
    CURRENT_REPO_SLUG="Nop.Plugin.Opensoft.$REPO_NAME_FROM_FILE"
    CURRENT_CLONE_DIR_ABSOLUTE="$NOPCOMMERCE_ROOT/$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG"

    # Determine paths relative to solution for this repo
    if [ -n "$SUB_PROJECT_DIR" ]; then
        CURRENT_PROJECT_PATH_FOR_SLN="../$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG/$CURRENT_REPO_SLUG.csproj"
        CURRENT_GITIGNORE_RELATIVE_DIR="$SUB_PROJECT_DIR/$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG"
    else
        CURRENT_PROJECT_PATH_FOR_SLN="$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG/$CURRENT_REPO_SLUG.csproj"
        CURRENT_GITIGNORE_RELATIVE_DIR="$PLUGIN_ROOT_RELATIVE_TO_WORKSPACE/$CURRENT_REPO_SLUG"
    fi

    echo "--- Removing $REPO_NAME_FROM_FILE ---"

    # Remove folder
    if [ -d "$CURRENT_CLONE_DIR_ABSOLUTE" ]; then
      log "Removing folder: $CURRENT_CLONE_DIR_ABSOLUTE"
      rm -rf "$CURRENT_CLONE_DIR_ABSOLUTE"
      if [ $? -ne 0 ]; then echo "Error removing folder $CURRENT_CLONE_DIR_ABSOLUTE. Skipping rest for this repo."; continue; fi
      echo "Folder '$CURRENT_CLONE_DIR_ABSOLUTE' removed."
    else echo "Folder '$CURRENT_CLONE_DIR_ABSOLUTE' does not exist."; fi

    # Remove gitignore entry
    if [ -f "$GITIGNORE_PATH" ]; then
      log "Removing '$CURRENT_GITIGNORE_RELATIVE_DIR/' from .gitignore..."
      # Use a different delimiter for sed in case paths contain /
      sed -i "\|^$CURRENT_GITIGNORE_RELATIVE_DIR/$|d" "$GITIGNORE_PATH"
      log "Committing .gitignore changes..."
      cd "$(dirname "$GITIGNORE_PATH")" || exit 1
      git add .gitignore
      git commit -m "Removed .gitignore entry for '$CURRENT_GITIGNORE_RELATIVE_DIR/'"
      cd "$NOPCOMMERCE_ROOT" || exit 1
    else echo "Error: .gitignore not found at '$GITIGNORE_PATH'."; fi

    # Remove from solution
    if [ -f "$SOLUTION_FILE" ]; then
      log "Changing directory to solution directory: $SOLUTION_DIR"
      cd "$SOLUTION_DIR" || exit 1
      log "Removing '$CURRENT_PROJECT_PATH_FOR_SLN' from solution..."
      dotnet sln "$SOLUTION_FILE" remove "$CURRENT_PROJECT_PATH_FOR_SLN"
      # Don't error out if remove fails, project might not be there
      if [ $? -ne 0 ]; then echo "Warning: Failed to remove '$CURRENT_PROJECT_PATH_FOR_SLN' from solution (maybe it wasn't there?)."; fi
      cd "$NOPCOMMERCE_ROOT" || exit 1
    else echo "Error: Solution file '$SOLUTION_FILE' not found."; fi

    echo "--- Finished removing $REPO_NAME_FROM_FILE ---"

  done < "$PLUGIN_LIST_FILE"

  echo "All repositories for site '$SITE_NAME' listed in $PLUGIN_LIST_FILE have been removed."
  exit 0
fi
