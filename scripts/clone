#!/bin/bash

# Function to display help
show_help() {
  cat << EOF
Clone Script - Manage NopCommerce plugin repositories with Pattern Learning

USAGE:
  clone [OPTIONS] <repo-name>
  clone [OPTIONS] --site <site-name>
  clone --remove [OPTIONS] <repo-name>
  clone --remove --site <site-name>

OPTIONS:
  -h, --help              Show this help message
  -v, --verbose           Enable verbose output
  -rm, --remove           Remove repository instead of cloning
  -s, --site              Clone/remove all repositories for a specific site
  --pattern <pattern>     Use specific pattern (e.g., 'Nop.Plugin.Misc.{name}')
  --full-name <name>      Use exact repository name
  --discover              Test all patterns to find existing repositories
  --list-patterns         Show all known patterns
  --clear-cache           Clear the pattern learning cache

EXAMPLES:
  clone MyPlugin                                    # Clone using pattern learning
  clone --verbose MyPlugin                          # Clone with verbose output
  clone --remove MyPlugin                           # Remove a plugin
  clone --site MySite                               # Clone all plugins for a site
  clone --remove --site MySite                      # Remove all plugins for a site
  clone --pattern 'Nop.Plugin.Misc.{name}' MyPlugin # Use specific pattern
  clone --full-name 'Nop.Plugin.Exact.Name'        # Use exact repository name
  clone --discover MyPlugin                         # Find all matching repositories
  clone --list-patterns                             # Show all known patterns
  clone --clear-cache                               # Clear pattern cache

DESCRIPTION:
  This script manages NopCommerce plugin repositories with intelligent pattern learning.
  It automatically discovers the correct repository pattern by trying multiple known
  patterns and caching successful ones for future use.

  The pattern learning system supports various NopCommerce plugin categories:
  - Nop.Plugin.Opensoft.{name}     (Default pattern)
  - Nop.Plugin.Misc.{name}         (Miscellaneous plugins)
  - Nop.Plugin.Payments.{name}     (Payment providers)
  - Nop.Plugin.Shipping.{name}     (Shipping providers)
  - Nop.Plugin.Widgets.{name}      (Widget plugins)
  - Nop.Plugin.Tax.{name}          (Tax providers)
  - And many more...

  For site operations, the script reads from PluginList.txt files located at:
  sites/<site-name>/PluginList.txt

PATTERN LEARNING:
  The script automatically learns which patterns work for each plugin and caches
  the results. This means:
  - First time: Tries multiple patterns to find the correct one
  - Subsequent times: Uses cached pattern for instant cloning
  - Intelligence: Suggests likely patterns based on plugin names

CACHE MANAGEMENT:
  Pattern cache is stored in: ~/.clone_pattern_cache
  Use --clear-cache to reset the learning cache if needed.
EOF
}

# Check for help option first
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
  show_help
  exit 0
fi

# Pattern learning system configuration
PATTERN_CACHE_FILE="$HOME/.clone_pattern_cache"

# Known NopCommerce plugin patterns (ordered by likelihood)
PLUGIN_PATTERNS=(
    "Nop.Plugin.Opensoft.{name}"           # Current default
    "Nop.Plugin.Misc.{name}"               # Miscellaneous plugins
    "Nop.Plugin.{name}"                    # Direct plugin name
    "Nop.Plugin.Widgets.{name}"            # Widget plugins
    "Nop.Plugin.Payments.{name}"           # Payment plugins
    "Nop.Plugin.Shipping.{name}"           # Shipping plugins
    "Nop.Plugin.Tax.{name}"                # Tax plugins
    "Nop.Plugin.ExternalAuth.{name}"       # External authentication
    "Nop.Plugin.DiscountRules.{name}"      # Discount rules
    "Nop.Plugin.MultiFactorAuth.{name}"    # Multi-factor authentication
    "Nop.Plugin.Pickup.{name}"             # Pickup plugins
    "Nop.Plugin.Api.{name}"                # API plugins
)

# Function to get cached pattern for a plugin
get_cached_pattern() {
    local plugin_name="$1"
    if [ -f "$PATTERN_CACHE_FILE" ]; then
        grep "^$plugin_name|" "$PATTERN_CACHE_FILE" | cut -d'|' -f2 | head -1
    fi
}

# Function to cache successful pattern
cache_pattern() {
    local plugin_name="$1"
    local pattern="$2"
    local timestamp=$(date +%Y-%m-%d)

    # Create cache directory if it doesn't exist
    mkdir -p "$(dirname "$PATTERN_CACHE_FILE")"

    # Remove old entry if exists
    if [ -f "$PATTERN_CACHE_FILE" ]; then
        grep -v "^$plugin_name|" "$PATTERN_CACHE_FILE" > "$PATTERN_CACHE_FILE.tmp" 2>/dev/null || true
        mv "$PATTERN_CACHE_FILE.tmp" "$PATTERN_CACHE_FILE" 2>/dev/null || true
    fi

    # Add new entry
    echo "$plugin_name|$pattern|$timestamp" >> "$PATTERN_CACHE_FILE"
    log "Cached pattern for $plugin_name: $pattern"
}

# Function to check if repository exists
check_repository_exists() {
    local repo_url="$1"
    log "Checking repository existence: $repo_url"
    git ls-remote "$repo_url" &>/dev/null
    local result=$?
    if [ $result -eq 0 ]; then
        log "Repository exists: $repo_url"
    else
        log "Repository does not exist: $repo_url"
    fi
    return $result
}

# Function to get pattern hints based on plugin name
get_pattern_hints() {
    local plugin_name="$1"
    local hints=()

    case "${plugin_name,,}" in
        *payment*|*paypal*|*stripe*|*square*|*authorizenet*|*braintree*)
            hints+=("Nop.Plugin.Payments.{name}")
            ;;
        *shipping*|*fedex*|*ups*|*usps*|*pickup*)
            hints+=("Nop.Plugin.Shipping.{name}" "Nop.Plugin.Pickup.{name}")
            ;;
        *widget*|*slider*|*banner*|*carousel*|*gallery*)
            hints+=("Nop.Plugin.Widgets.{name}")
            ;;
        *tax*|*avalara*|*taxjar*|*taxcloud*)
            hints+=("Nop.Plugin.Tax.{name}")
            ;;
        *auth*|*facebook*|*google*|*oauth*|*openid*|*twitter*)
            hints+=("Nop.Plugin.ExternalAuth.{name}")
            ;;
        *discount*|*rule*)
            hints+=("Nop.Plugin.DiscountRules.{name}")
            ;;
        *api*|*webapi*|*rest*)
            hints+=("Nop.Plugin.Api.{name}")
            ;;
        *multifactor*|*2fa*|*mfa*)
            hints+=("Nop.Plugin.MultiFactorAuth.{name}")
            ;;
        *)
            hints+=("Nop.Plugin.Misc.{name}" "Nop.Plugin.{name}")
            ;;
    esac

    printf '%s\n' "${hints[@]}"
}

# Function to find the correct repository pattern
find_repository_pattern() {
    local plugin_name="$1"
    local base_url="$2"

    # Check cache first
    local cached_pattern=$(get_cached_pattern "$plugin_name")
    if [ -n "$cached_pattern" ]; then
        log "Using cached pattern for $plugin_name: $cached_pattern"
        echo "$cached_pattern"
        return 0
    fi

    log "No cached pattern found for $plugin_name, trying patterns..."

    # Get pattern hints and merge with standard patterns
    local hints=($(get_pattern_hints "$plugin_name"))
    local all_patterns=("${hints[@]}" "${PLUGIN_PATTERNS[@]}")

    # Remove duplicates while preserving order
    local unique_patterns=()
    local seen=()
    for pattern in "${all_patterns[@]}"; do
        if [[ ! " ${seen[@]} " =~ " ${pattern} " ]]; then
            unique_patterns+=("$pattern")
            seen+=("$pattern")
        fi
    done

    # Try each pattern
    for pattern in "${unique_patterns[@]}"; do
        local repo_slug="${pattern//\{name\}/$plugin_name}"
        local repo_url="$base_url/$repo_slug"

        log "Trying pattern: $pattern -> $repo_slug"

        if check_repository_exists "$repo_url"; then
            cache_pattern "$plugin_name" "$repo_slug"
            echo "$repo_slug"
            return 0
        fi
    done

    return 1
}

# Function to suggest alternatives when no pattern works
suggest_alternatives() {
    local plugin_name="$1"

    echo "‚ùå Repository not found with any known pattern for: $plugin_name"
    echo ""
    echo "üîç Tried the following patterns:"
    local hints=($(get_pattern_hints "$plugin_name"))
    local all_patterns=("${hints[@]}" "${PLUGIN_PATTERNS[@]}")
    local unique_patterns=()
    local seen=()
    for pattern in "${all_patterns[@]}"; do
        if [[ ! " ${seen[@]} " =~ " ${pattern} " ]]; then
            echo "   - ${pattern//\{name\}/$plugin_name}"
            unique_patterns+=("$pattern")
            seen+=("$pattern")
        fi
    done
    echo ""
    echo "üí° Suggestions:"
    echo "1. Use manual pattern: clone --pattern 'Nop.Plugin.Category.{name}' $plugin_name"
    echo "2. Use full repository name: clone --full-name 'Exact.Repository.Name'"
    echo "3. Check repository name in Azure DevOps"
    echo "4. Try pattern discovery: clone --discover $plugin_name"
    echo ""
    echo "üìù If you know the correct pattern, it will be cached for future use."
}

# Enable verbose mode if --verbose or -v is passed
VERBOSE=false
if [[ "$1" == "--verbose" || "$1" == "-v" ]]; then
  VERBOSE=true
  shift
fi

# Function to echo messages in verbose mode
log() {
  if [ "$VERBOSE" = true ]; then
    echo "[DEBUG] $1" >&2
  fi
}

# Function to process a single repository (clone or remove)
process_repository() {
  local operation="$1"
  local repo_name="$2"
  local provided_repo_slug="$3"  # Optional: pre-determined repo slug
  local repo_slug=""

  # Determine repository slug
  if [[ -n "$provided_repo_slug" ]]; then
    repo_slug="$provided_repo_slug"
    log "Using provided repository slug: $repo_slug"
  else
    # Use pattern learning to find the correct repository slug
    repo_slug=$(find_repository_pattern "$repo_name" "$DEVOPS_PROJECT")
    if [ $? -ne 0 ] || [ -z "$repo_slug" ]; then
      suggest_alternatives "$repo_name"
      return 1
    fi
    log "Pattern learning found repository slug: $repo_slug"
  fi

  local clone_dir="$PLUGINS_DIR/$repo_slug"

  if [[ "$operation" == "clone" ]]; then
    echo "--- Cloning $repo_name ---"
    echo "Repository: $repo_slug"
  else
    echo "--- Removing $repo_name ---"
    echo "Repository: $repo_slug"
  fi

  if [[ "$operation" == "clone" ]]; then
    if [ -d "$clone_dir" ]; then
      echo "Repository $repo_slug already exists. Skipping clone."
      return 0
    fi

    local repo_url="$DEVOPS_PROJECT/$repo_slug"
    log "Cloning from: $repo_url"

    git clone "$repo_url" "$clone_dir"
    if [ $? -ne 0 ]; then
      echo "Error cloning $repo_slug."
      # If we used pattern learning and it failed, remove from cache
      if [[ -z "$provided_repo_slug" ]]; then
        log "Removing failed pattern from cache"
        if [ -f "$PATTERN_CACHE_FILE" ]; then
          grep -v "^$repo_name|" "$PATTERN_CACHE_FILE" > "$PATTERN_CACHE_FILE.tmp" 2>/dev/null || true
          mv "$PATTERN_CACHE_FILE.tmp" "$PATTERN_CACHE_FILE" 2>/dev/null || true
        fi
      fi
      return 1
    fi

    cd "$clone_dir" || {
      echo "Error accessing directory $clone_dir. Skipping."
      return 1
    }

    git checkout 4.80/develop
    if [ $? -ne 0 ]; then
      echo "Error checking out branch for $repo_slug. Skipping."
      return 1
    fi

    cd "$SOLUTION_DIR" || return 1
    if [ -f "Plugins/$repo_slug/$repo_slug.csproj" ]; then
      # Check if dotnet command is available
      if ! command -v dotnet &> /dev/null; then
        echo "dotnet command not found. Adding project to solution manually..."
        # Generate a GUID for the project
        project_guid=$(uuidgen | tr '[:lower:]' '[:upper:]')

        # Check if project already exists in solution
        if grep -q "Project.*$repo_slug" "$CHOSEN_SOLUTION"; then
          echo "Project $repo_slug already exists in solution. Skipping."
          return 0
        fi

        # Add the project entry as a separate project block after the Plugins folder
        sed -i "/Project(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Plugins\"/,/^EndProject$/ {
          /^EndProject$/ a\\Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"$repo_slug\", \"Plugins\\\\$repo_slug\\\\$repo_slug.csproj\", \"{$project_guid}\"\\nEndProject
        }" "$CHOSEN_SOLUTION"

        # Add the project to the Plugins folder in NestedProjects section
        if grep -q "GlobalSection(NestedProjects)" "$CHOSEN_SOLUTION"; then
          sed -i "/GlobalSection(NestedProjects) = preSolution/a \		{$project_guid} = {07D57EEB-2F50-60C4-C011-FE4FA775C9A8}" "$CHOSEN_SOLUTION"
        else
          # Add NestedProjects section if it doesn't exist
          sed -i "/GlobalSection(SolutionProperties)/i \	GlobalSection(NestedProjects) = preSolution\\n\		{$project_guid} = {07D57EEB-2F50-60C4-C011-FE4FA775C9A8}\\n\	EndGlobalSection" "$CHOSEN_SOLUTION"
        fi

        echo "Project $repo_slug added to solution manually."
      else
        dotnet sln "$CHOSEN_SOLUTION" add --solution-folder Plugins "Plugins/$repo_slug/$repo_slug.csproj"
        if [ $? -eq 0 ]; then
          echo "Project $repo_slug added to solution."
        else
          echo "Warning: Failed to add $repo_slug to solution."
        fi
      fi
    else
      echo "Warning: Project file not found for $repo_slug"
    fi
  elif [[ "$operation" == "remove" ]]; then
    if [ -d "$clone_dir" ]; then
      rm -rf "$clone_dir"
      echo "Folder '$clone_dir' removed."
    else
      echo "Folder '$clone_dir' does not exist."
    fi

    cd "$SOLUTION_DIR" || return 1
    # Use dotnet sln remove since we have a placeholder plugin to prevent empty folder removal
    if command -v dotnet &> /dev/null; then
      dotnet sln "$CHOSEN_SOLUTION" remove "Plugins/$repo_slug/$repo_slug.csproj"
      if [ $? -eq 0 ]; then
        echo "Project $repo_slug removed from solution."
      else
        echo "Warning: Failed to remove $repo_slug from solution (may not have been in solution)."
      fi
    else
      echo "dotnet command not found. Removing project from solution manually..."

      # First, extract the project GUID from the solution file
      project_guid=$(grep "Project.*$repo_slug" "$CHOSEN_SOLUTION" | sed -n 's/.*{\([A-F0-9-]*\)}"$/\1/p')

      if [ -n "$project_guid" ]; then
        echo "Found project GUID: $project_guid"

        # Create temporary file for processing
        temp_file=$(mktemp)

        # Remove project entry lines (Project declaration and its EndProject)
        awk "
        /Project.*$repo_slug/ { skip=1; next }
        skip && /^[[:space:]]*EndProject/ { skip=0; next }
        !skip { print }
        " "$CHOSEN_SOLUTION" > "$temp_file"

        # Remove NestedProjects entry for this project
        sed -i "/{$project_guid}/d" "$temp_file"

        # Remove ProjectConfigurationPlatforms entries for this project
        sed -i "/{$project_guid}\./d" "$temp_file"

        mv "$temp_file" "$CHOSEN_SOLUTION"
        echo "Project $repo_slug removed from solution manually."
      else
        echo "Warning: Could not find project $repo_slug in solution file."
      fi
    fi
  fi

  if [[ "$operation" == "clone" ]]; then
    echo "--- Finished cloning $repo_name ---"
  else
    echo "--- Finished removing $repo_name ---"
  fi
  return 0
}

log "Starting clone script"

# Initialize variables
VERBOSE=false
REMOVE=false
SITE_MODE=false
REPO_NAME=""
SITE_NAME=""
MANUAL_PATTERN=""
FULL_NAME=""
DISCOVER_MODE=false
LIST_PATTERNS=false
CLEAR_CACHE=false

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --verbose|-v)
      VERBOSE=true
      shift
      ;;
    --remove|-rm)
      REMOVE=true
      shift
      ;;
    --site|-s)
      SITE_MODE=true
      shift
      ;;
    --pattern)
      if [[ -z "$2" ]]; then
        echo "Error: --pattern requires a pattern argument"
        echo "Example: clone --pattern 'Nop.Plugin.Misc.{name}' PluginName"
        exit 1
      fi
      MANUAL_PATTERN="$2"
      shift 2
      ;;
    --full-name)
      if [[ -z "$2" ]]; then
        echo "Error: --full-name requires a repository name argument"
        echo "Example: clone --full-name 'Nop.Plugin.Exact.Repository.Name'"
        exit 1
      fi
      FULL_NAME="$2"
      shift 2
      ;;
    --discover)
      DISCOVER_MODE=true
      shift
      ;;
    --list-patterns)
      LIST_PATTERNS=true
      shift
      ;;
    --clear-cache)
      CLEAR_CACHE=true
      shift
      ;;
    -*)
      # Handle combined flags like -s or check for invalid flags
      if [[ "$1" == "-r" ]]; then
        echo "Error: Invalid option '-r'. Did you mean 'clone -rm <repo-name>'?"
        exit 1
      else
        echo "Error: Unknown option '$1'"
        echo "Usage: clone [--verbose | -v] [--remove | -rm] [--site | -s] [--pattern <pattern>] [--full-name <name>] [--discover] [--list-patterns] [--clear-cache] <repo-name-or-site-name>"
        exit 1
      fi
      ;;
    *)
      # This should be the repository name or site name
      if [[ $SITE_MODE == true ]]; then
        SITE_NAME="$1"
      elif [[ -n "$FULL_NAME" ]]; then
        # Full name already provided, this is unexpected
        echo "Error: Unexpected argument '$1' when using --full-name"
        exit 1
      else
        REPO_NAME="$1"
      fi
      shift
      ;;
  esac
done

# Handle utility commands first
if [[ $LIST_PATTERNS == true ]]; then
  echo "Known NopCommerce plugin patterns:"
  for i in "${!PLUGIN_PATTERNS[@]}"; do
    echo "  $((i+1)). ${PLUGIN_PATTERNS[$i]}"
  done
  exit 0
fi

if [[ $CLEAR_CACHE == true ]]; then
  if [ -f "$PATTERN_CACHE_FILE" ]; then
    rm -f "$PATTERN_CACHE_FILE"
    echo "Pattern cache cleared successfully."
  else
    echo "Pattern cache file does not exist."
  fi
  exit 0
fi

# Handle discovery mode
if [[ $DISCOVER_MODE == true ]]; then
  if [[ -z "$REPO_NAME" ]]; then
    echo "Error: Discovery mode requires a plugin name."
    echo "Usage: clone --discover <plugin-name>"
    exit 1
  fi

  echo "üîç Discovering available patterns for: $REPO_NAME"
  echo ""

  DEVOPS_PROJECT="FarHeapSolutions@vs-ssh.visualstudio.com:v3/FarHeapSolutions/Nop%20Plugins"
  hints=($(get_pattern_hints "$REPO_NAME"))
  all_patterns=("${hints[@]}" "${PLUGIN_PATTERNS[@]}")
  unique_patterns=()
  seen=()
  for pattern in "${all_patterns[@]}"; do
    if [[ ! " ${seen[@]} " =~ " ${pattern} " ]]; then
      unique_patterns+=("$pattern")
      seen+=("$pattern")
    fi
  done

  found_patterns=()
  for pattern in "${unique_patterns[@]}"; do
    repo_slug="${pattern//\{name\}/$REPO_NAME}"
    repo_url="$DEVOPS_PROJECT/$repo_slug"

    echo -n "Testing: $repo_slug ... "
    if check_repository_exists "$repo_url"; then
      echo "‚úÖ EXISTS"
      found_patterns+=("$repo_slug")
    else
      echo "‚ùå Not found"
    fi
  done

  echo ""
  if [ ${#found_patterns[@]} -eq 0 ]; then
    echo "‚ùå No matching repositories found."
    suggest_alternatives "$REPO_NAME"
  elif [ ${#found_patterns[@]} -eq 1 ]; then
    echo "‚úÖ Found one matching repository: ${found_patterns[0]}"
    echo "To clone: clone $REPO_NAME"
  else
    echo "‚úÖ Found multiple matching repositories:"
    for pattern in "${found_patterns[@]}"; do
      echo "  - $pattern"
    done
    echo ""
    echo "Multiple matches found. The first one will be used by default."
  fi
  exit 0
fi

# Validate arguments
if [[ $SITE_MODE == true ]]; then
  if [[ -z "$SITE_NAME" ]]; then
    echo "Error: The --site or -s option must be followed by a site name."
    echo "Usage: clone [--verbose | -v] [--remove | -rm] --site <site-name>"
    exit 1
  fi
else
  if [[ -n "$FULL_NAME" ]]; then
    REPO_SLUG="$FULL_NAME"
    # Extract repo name from full name for display purposes
    REPO_NAME=$(echo "$FULL_NAME" | sed 's/.*\.//')
  elif [[ -n "$MANUAL_PATTERN" ]]; then
    if [[ -z "$REPO_NAME" ]]; then
      echo "Error: Manual pattern requires a plugin name."
      echo "Usage: clone --pattern 'Nop.Plugin.Category.{name}' <plugin-name>"
      exit 1
    fi
    REPO_SLUG="${MANUAL_PATTERN//\{name\}/$REPO_NAME}"
  elif [[ -z "$REPO_NAME" ]]; then
    echo "Usage: clone [options] <repo-name-or-site-name>"
    echo "Try: clone --help for more information"
    exit 1
  fi
fi
DEVOPS_PROJECT="FarHeapSolutions@vs-ssh.visualstudio.com:v3/FarHeapSolutions/Nop%20Plugins"

# Get current directory
CURRENT_DIR=$(pwd)
log "Current directory: $CURRENT_DIR"

# Search for solution files
SOLUTION_COUNT=0
declare -a SOLUTION_LIST
CHOSEN_SOLUTION=""

# Function to search down directories
search_down() {
  local search_path="$1"
  local depth="$2"

  if [ "$depth" -ge 3 ]; then
    return
  fi

  log "Searching down in: $search_path (depth $depth)"

  # Check for .sln files in current directory
  for sln_file in "$search_path"/*.sln; do
    if [ -f "$sln_file" ]; then
      # Normalize the path to remove double slashes
      normalized_path=$(realpath "$sln_file" 2>/dev/null || echo "$sln_file")
      SOLUTION_LIST+=("$normalized_path")
      ((SOLUTION_COUNT++))
      log "Found solution: $normalized_path"
    fi
  done

  # Search subdirectories
  local next_depth=$((depth + 1))
  for dir in "$search_path"/*/; do
    if [ -d "$dir" ]; then
      search_down "$dir" "$next_depth"
    fi
  done
}

# Search up the directory tree
SEARCH_DIR="$CURRENT_DIR"
while true; do
  log "Searching up in: $SEARCH_DIR"

  # Check for .sln files in current search directory
  for sln_file in "$SEARCH_DIR"/*.sln; do
    if [ -f "$sln_file" ]; then
      # Normalize the path to remove double slashes
      normalized_path=$(realpath "$sln_file" 2>/dev/null || echo "$sln_file")
      SOLUTION_LIST+=("$normalized_path")
      ((SOLUTION_COUNT++))
      log "Found solution: $normalized_path"
    fi
  done

  # Check if we've reached nopSetup or workspace folder
  DIR_NAME=$(basename "$SEARCH_DIR")
  if [[ "${DIR_NAME,,}" == "nopsetup" || "${DIR_NAME,,}" == "workspace" ]]; then
    log "Reached stop directory: $DIR_NAME"
    break
  fi

  # Move up one directory
  PARENT_DIR=$(dirname "$SEARCH_DIR")
  if [ "$SEARCH_DIR" == "$PARENT_DIR" ] || [ "$PARENT_DIR" == "/" ]; then
    log "Reached filesystem root"
    break
  fi
  SEARCH_DIR="$PARENT_DIR"
done

# If no solutions found going up, search down 3 levels
if [ "$SOLUTION_COUNT" -eq 0 ]; then
  log "No solutions found going up, searching down 3 levels"
  search_down "$CURRENT_DIR" 0
fi

# Handle solution selection
if [ "$SOLUTION_COUNT" -eq 0 ]; then
  echo "No solution file found"
  exit 1
elif [ "$SOLUTION_COUNT" -eq 1 ]; then
  CHOSEN_SOLUTION="${SOLUTION_LIST[0]}"
  log "Using single solution: $CHOSEN_SOLUTION"
else
  echo "Multiple solution files found:"
  for i in "${!SOLUTION_LIST[@]}"; do
    echo "$((i+1)). ${SOLUTION_LIST[$i]}"
  done
  read -p "Please choose a solution file (1-$SOLUTION_COUNT): " CHOICE
  if [[ "$CHOICE" =~ ^[0-9]+$ ]] && [ "$CHOICE" -ge 1 ] && [ "$CHOICE" -le "$SOLUTION_COUNT" ]; then
    CHOSEN_SOLUTION="${SOLUTION_LIST[$((CHOICE-1))]}"
  else
    echo "Invalid selection"
    exit 1
  fi
fi

# Get solution directory

# Copy solution template if it exists and target does not
if [ -f "$SOLUTION_DIR/src/NopCommerce.sln.template" ] && [ ! -f "$SOLUTION_DIR/src/NopCommerce.sln" ]; then
  echo "Creating solution file from template..."
  cp "$SOLUTION_DIR/src/NopCommerce.sln.template" "$SOLUTION_DIR/src/NopCommerce.sln"
fi

SOLUTION_DIR=$(dirname "$CHOSEN_SOLUTION")
log "Solution directory: $SOLUTION_DIR"

# Copy solution template if it exists and target does not
if [ -f "$SOLUTION_DIR/src/NopCommerce.sln.template" ] && [ ! -f "$SOLUTION_DIR/src/NopCommerce.sln" ]; then
  echo "Creating solution file from template..."
  cp "$SOLUTION_DIR/src/NopCommerce.sln.template" "$SOLUTION_DIR/src/NopCommerce.sln"
fi


# Validate solution file for Plugins folder declaration
log "Validating solution file for Plugins folder"
if ! grep -q 'Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Plugins"' "$CHOSEN_SOLUTION"; then
  echo "Error: No plugins solution folder declaration in solution file"
  exit 1
fi

log "Plugins folder declaration found with correct GUID"

# Check if Plugins folder exists
if [ ! -d "$SOLUTION_DIR/Plugins" ]; then
  echo "Error: Plugins folder not where expected"
  exit 1
fi

PLUGINS_DIR="$SOLUTION_DIR/Plugins"
CLONE_DIR="$PLUGINS_DIR/$REPO_SLUG"
log "Plugins directory: $PLUGINS_DIR"
log "Clone directory: $CLONE_DIR"

# Handle operations based on parsed arguments
if [[ $SITE_MODE == true ]]; then
  # Look for PluginList.txt in the sites folder at the workspace root
  WORKSPACE_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
  PLUGIN_LIST_FILE="$WORKSPACE_ROOT/sites/$SITE_NAME/PluginList.txt"

  if [ ! -f "$PLUGIN_LIST_FILE" ]; then
    echo "Error: PluginList.txt file not found at '$PLUGIN_LIST_FILE'."
    exit 1
  fi

  if [[ $REMOVE == true ]]; then
    echo "Removing repositories for site '$SITE_NAME' listed in $PLUGIN_LIST_FILE..."
    OPERATION_NAME="remove"
  else
    echo "Cloning repositories for site '$SITE_NAME' listed in $PLUGIN_LIST_FILE..."
    OPERATION_NAME="clone"
  fi

  # Count total repositories for progress tracking
  TOTAL_REPOS=$(grep -v '^#\|^$' "$PLUGIN_LIST_FILE" | wc -l)
  CURRENT_REPO=0

  while IFS= read -r REPO_NAME_FROM_FILE || [ -n "$REPO_NAME_FROM_FILE" ]; do
    if [[ -z "$REPO_NAME_FROM_FILE" || "$REPO_NAME_FROM_FILE" == \#* ]]; then
      continue
    fi

    CURRENT_REPO=$((CURRENT_REPO + 1))
    echo "[$CURRENT_REPO/$TOTAL_REPOS] Processing repository: $REPO_NAME_FROM_FILE"

    process_repository "$OPERATION_NAME" "$REPO_NAME_FROM_FILE"

  done < "$PLUGIN_LIST_FILE"

  if [[ $REMOVE == true ]]; then
    echo "All repositories for site '$SITE_NAME' have been removed."
  else
    echo "All repositories for site '$SITE_NAME' processed."
  fi
  exit 0
fi

# Handle single repository operations
if [[ $REMOVE == true ]]; then
  echo "Removing repository..."
  if [[ -n "$REPO_SLUG" ]]; then
    # Use predetermined repo slug (from manual pattern or full name)
    process_repository "remove" "$REPO_NAME" "$REPO_SLUG"
  else
    # Use pattern learning
    process_repository "remove" "$REPO_NAME"
  fi
  cd "$CURRENT_DIR"
  echo "Repository removal completed."
  exit 0
fi

# Clone the repository
echo "Cloning repository..."
if [[ -n "$REPO_SLUG" ]]; then
  # Use predetermined repo slug (from manual pattern or full name)
  echo "Using specified repository: $REPO_SLUG"
  process_repository "clone" "$REPO_NAME" "$REPO_SLUG"
else
  # Use pattern learning
  echo "Using pattern learning to find repository..."
  process_repository "clone" "$REPO_NAME"
fi

cd "$CURRENT_DIR"
echo "Script completed successfully."
